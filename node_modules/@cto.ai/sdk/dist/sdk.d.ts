/// <reference types="yargs-parser" />
import { User, Team } from './types';
import * as yargsOrig from 'yargs';
export declare const yargs: {
    default: yargsOrig.Argv<{}>;
    alias<K1 extends never, K2 extends string>(shortName: K1, longName: K2 | readonly K2[]): yargsOrig.Argv<{ [key in K2]: {}[K1]; }>;
    alias<K1 extends never, K2 extends string>(shortName: K2, longName: K1 | readonly K1[]): yargsOrig.Argv<{ [key in K2]: {}[K1]; }>;
    alias(shortName: string | readonly string[], longName: string | readonly string[]): yargsOrig.Argv<{}>;
    alias(aliases: {
        [shortName: string]: string | readonly string[];
    }): yargsOrig.Argv<{}>;
    argv: {
        [x: string]: unknown;
        _: string[];
        $0: string;
    };
    array<K extends never>(key: K | readonly K[]): yargsOrig.Argv<yargsOrig.Omit<{}, K> & { [key in K]: yargsOrig.ToArray<{}[key]>; }>;
    array<K extends string>(key: K | readonly K[]): yargsOrig.Argv<{ [key in K]: (string | number)[] | undefined; }>;
    boolean<K extends never>(key: K | readonly K[]): yargsOrig.Argv<yargsOrig.Omit<{}, K> & { [key in K]: boolean | undefined; }>;
    boolean<K extends string>(key: K | readonly K[]): yargsOrig.Argv<{ [key in K]: boolean | undefined; }>;
    check(func: (argv: {
        [argName: string]: unknown;
        _: string[];
        $0: string;
    }, aliases: {
        [alias: string]: string;
    }) => any, global?: boolean | undefined): yargsOrig.Argv<{}>;
    choices<K extends never, C extends readonly any[]>(key: K, values: C): yargsOrig.Argv<yargsOrig.Omit<{}, K> & { [key in K]: C[number] | undefined; }>;
    choices<K extends string, C extends readonly any[]>(key: K, values: C): yargsOrig.Argv<{ [key in K]: C[number] | undefined; }>;
    choices<C extends {
        [key: string]: readonly any[];
    }>(choices: C): yargsOrig.Argv<yargsOrig.Omit<{}, keyof C> & { [key in keyof C]: C[key][number] | undefined; }>;
    coerce<K extends never, V>(key: K | readonly K[], func: (arg: any) => V): yargsOrig.Argv<yargsOrig.Omit<{}, K> & { [key in K]: V | undefined; }>;
    coerce<K extends string, V>(key: K | readonly K[], func: (arg: any) => V): yargsOrig.Argv<{ [key in K]: V | undefined; }>;
    coerce<O extends {
        [key: string]: (arg: any) => any;
    }>(opts: O): yargsOrig.Argv<yargsOrig.Omit<{}, keyof O> & { [key in keyof O]: ReturnType<O[key]> | undefined; }>;
    command<U>(command: string | readonly string[], description: string, builder?: ((args: yargsOrig.Argv<{}>) => yargsOrig.Argv<U>) | undefined, handler?: ((args: yargsOrig.Arguments<U>) => void) | undefined): yargsOrig.Argv<{}>;
    command<O extends {
        [key: string]: yargsOrig.Options;
    }>(command: string | readonly string[], description: string, builder?: O | undefined, handler?: ((args: yargsOrig.Arguments<yargsOrig.InferredOptionTypes<O>>) => void) | undefined): yargsOrig.Argv<{}>;
    command<U>(command: string | readonly string[], description: string, module: yargsOrig.CommandModule<{}, U>): yargsOrig.Argv<U>;
    command<U>(command: string | readonly string[], showInHelp: false, builder?: ((args: yargsOrig.Argv<{}>) => yargsOrig.Argv<U>) | undefined, handler?: ((args: yargsOrig.Arguments<U>) => void) | undefined): yargsOrig.Argv<{}>;
    command<O extends {
        [key: string]: yargsOrig.Options;
    }>(command: string | readonly string[], showInHelp: false, builder?: O | undefined, handler?: ((args: yargsOrig.Arguments<yargsOrig.InferredOptionTypes<O>>) => void) | undefined): yargsOrig.Argv<{}>;
    command<U>(command: string | readonly string[], showInHelp: false, module: yargsOrig.CommandModule<{}, U>): yargsOrig.Argv<U>;
    command<U>(module: yargsOrig.CommandModule<{}, U>): yargsOrig.Argv<U>;
    commandDir(dir: string, opts?: yargsOrig.RequireDirectoryOptions | undefined): yargsOrig.Argv<{}>;
    completion(): yargsOrig.Argv<{}>;
    completion(cmd: string, func?: yargsOrig.AsyncCompletionFunction | undefined): yargsOrig.Argv<{}>;
    completion(cmd: string, func?: yargsOrig.SyncCompletionFunction | undefined): yargsOrig.Argv<{}>;
    completion(cmd: string, func?: yargsOrig.PromiseCompletionFunction | undefined): yargsOrig.Argv<{}>;
    completion(cmd: string, description?: string | undefined, func?: yargsOrig.AsyncCompletionFunction | undefined): yargsOrig.Argv<{}>;
    completion(cmd: string, description?: string | undefined, func?: yargsOrig.SyncCompletionFunction | undefined): yargsOrig.Argv<{}>;
    completion(cmd: string, description?: string | undefined, func?: yargsOrig.PromiseCompletionFunction | undefined): yargsOrig.Argv<{}>;
    config(): yargsOrig.Argv<{}>;
    config(key: string | readonly string[], description?: string | undefined, parseFn?: ((configPath: string) => object) | undefined): yargsOrig.Argv<{}>;
    config(key: string | readonly string[], parseFn: (configPath: string) => object): yargsOrig.Argv<{}>;
    config(explicitConfigurationObject: object): yargsOrig.Argv<{}>;
    conflicts(key: string, value: string | readonly string[]): yargsOrig.Argv<{}>;
    conflicts(conflicts: {
        [key: string]: string | readonly string[];
    }): yargsOrig.Argv<{}>;
    count<K extends never>(key: K | readonly K[]): yargsOrig.Argv<yargsOrig.Omit<{}, K> & { [key in K]: number; }>;
    count<K extends string>(key: K | readonly K[]): yargsOrig.Argv<{ [key in K]: number; }>;
    demand<K extends never>(key: K | readonly K[], msg?: string | true | undefined): yargsOrig.Argv<yargsOrig.Defined<{}, K>>;
    demand<K extends string>(key: K | readonly K[], msg?: string | true | undefined): yargsOrig.Argv<{ [key in K]: unknown; }>;
    demand(key: string | readonly string[], required?: boolean | undefined): yargsOrig.Argv<{}>;
    demand(positionals: number, msg: string): yargsOrig.Argv<{}>;
    demand(positionals: number, required?: boolean | undefined): yargsOrig.Argv<{}>;
    demand(positionals: number, max: number, msg?: string | undefined): yargsOrig.Argv<{}>;
    demandOption<K extends never>(key: K | readonly K[], msg?: string | true | undefined): yargsOrig.Argv<yargsOrig.Defined<{}, K>>;
    demandOption<K extends string>(key: K | readonly K[], msg?: string | true | undefined): yargsOrig.Argv<{ [key in K]: unknown; }>;
    demandOption(key: string | readonly string[], demand?: boolean | undefined): yargsOrig.Argv<{}>;
    demandCommand(): yargsOrig.Argv<{}>;
    demandCommand(min: number, minMsg?: string | undefined): yargsOrig.Argv<{}>;
    demandCommand(min: number, max?: number | undefined, minMsg?: string | undefined, maxMsg?: string | undefined): yargsOrig.Argv<{}>;
    describe(key: string | readonly string[], description: string): yargsOrig.Argv<{}>;
    describe(descriptions: {
        [key: string]: string;
    }): yargsOrig.Argv<{}>;
    detectLocale(detect: boolean): yargsOrig.Argv<{}>;
    env(): yargsOrig.Argv<{}>;
    env(prefix: string): yargsOrig.Argv<{}>;
    env(enable: boolean): yargsOrig.Argv<{}>;
    epilog(msg: string): yargsOrig.Argv<{}>;
    epilogue(msg: string): yargsOrig.Argv<{}>;
    example(command: string, description: string): yargsOrig.Argv<{}>;
    exit(code: number, err: Error): void;
    exitProcess(enabled: boolean): yargsOrig.Argv<{}>;
    fail(func: (msg: string, err: Error) => any): yargsOrig.Argv<{}>;
    getCompletion(args: readonly string[], done: (completions: readonly string[]) => void): yargsOrig.Argv<{}>;
    global(key: string | readonly string[]): yargsOrig.Argv<{}>;
    group(key: string | readonly string[], groupName: string): yargsOrig.Argv<{}>;
    hide(key: string): yargsOrig.Argv<{}>;
    help(): yargsOrig.Argv<{}>;
    help(enableExplicit: boolean): yargsOrig.Argv<{}>;
    help(option: string, enableExplicit: boolean): yargsOrig.Argv<{}>;
    help(option: string, description?: string | undefined, enableExplicit?: boolean | undefined): yargsOrig.Argv<{}>;
    implies(key: string, value: string | readonly string[]): yargsOrig.Argv<{}>;
    implies(implies: {
        [key: string]: string | readonly string[];
    }): yargsOrig.Argv<{}>;
    locale(): string;
    locale(loc: string): yargsOrig.Argv<{}>;
    middleware(callbacks: yargsOrig.MiddlewareFunction<{}> | readonly yargsOrig.MiddlewareFunction<{}>[], applyBeforeValidation?: boolean | undefined): yargsOrig.Argv<{}>;
    nargs(key: string, count: number): yargsOrig.Argv<{}>;
    nargs(nargs: {
        [key: string]: number;
    }): yargsOrig.Argv<{}>;
    normalize<K extends never>(key: K | readonly K[]): yargsOrig.Argv<yargsOrig.Omit<{}, K> & { [key in K]: yargsOrig.ToString<{}[key]>; }>;
    normalize<K extends string>(key: K | readonly K[]): yargsOrig.Argv<{ [key in K]: string | undefined; }>;
    number<K extends never>(key: K | readonly K[]): yargsOrig.Argv<yargsOrig.Omit<{}, K> & { [key in K]: yargsOrig.ToNumber<{}[key]>; }>;
    number<K extends string>(key: K | readonly K[]): yargsOrig.Argv<{ [key in K]: number | undefined; }>;
    option<K extends never, O extends yargsOrig.Options>(key: K, options: O): yargsOrig.Argv<yargsOrig.Omit<{}, K> & { [key in K]: yargsOrig.InferredOptionType<O>; }>;
    option<K extends string, O extends yargsOrig.Options>(key: K, options: O): yargsOrig.Argv<{ [key in K]: yargsOrig.InferredOptionType<O>; }>;
    option<O extends {
        [key: string]: yargsOrig.Options;
    }>(options: O): yargsOrig.Argv<yargsOrig.Omit<{}, keyof O> & yargsOrig.InferredOptionTypes<O>>;
    options<K extends never, O extends yargsOrig.Options>(key: K, options: O): yargsOrig.Argv<yargsOrig.Omit<{}, K> & { [key in K]: yargsOrig.InferredOptionType<O>; }>;
    options<K extends string, O extends yargsOrig.Options>(key: K, options: O): yargsOrig.Argv<{ [key in K]: yargsOrig.InferredOptionType<O>; }>;
    options<O extends {
        [key: string]: yargsOrig.Options;
    }>(options: O): yargsOrig.Argv<yargsOrig.Omit<{}, keyof O> & yargsOrig.InferredOptionTypes<O>>;
    parse(): {
        [x: string]: unknown;
        _: string[];
        $0: string;
    };
    parse(arg: string | readonly string[], context?: object | undefined, parseCallback?: yargsOrig.ParseCallback<{}> | undefined): {
        [x: string]: unknown;
        _: string[];
        $0: string;
    };
    parsed: false | import("yargs-parser").DetailedArguments;
    parserConfiguration(configuration: Partial<import("yargs-parser").Configuration>): yargsOrig.Argv<{}>;
    pkgConf(key: string | readonly string[], cwd?: string | undefined): yargsOrig.Argv<{}>;
    positional<K extends never, O extends yargsOrig.PositionalOptions>(key: K, opt: O): yargsOrig.Argv<yargsOrig.Omit<{}, K> & { [key in K]: yargsOrig.InferredOptionType<O>; }>;
    positional<K extends string, O extends yargsOrig.PositionalOptions>(key: K, opt: O): yargsOrig.Argv<{ [key in K]: yargsOrig.InferredOptionType<O>; }>;
    recommendCommands(): yargsOrig.Argv<{}>;
    require<K extends never>(key: K | readonly K[], msg?: string | true | undefined): yargsOrig.Argv<yargsOrig.Defined<{}, K>>;
    require(key: string, msg: string): yargsOrig.Argv<{}>;
    require(key: string, required: boolean): yargsOrig.Argv<{}>;
    require(keys: readonly number[], msg: string): yargsOrig.Argv<{}>;
    require(keys: readonly number[], required: boolean): yargsOrig.Argv<{}>;
    require(positionals: number, required: boolean): yargsOrig.Argv<{}>;
    require(positionals: number, msg: string): yargsOrig.Argv<{}>;
    required<K extends never>(key: K | readonly K[], msg?: string | true | undefined): yargsOrig.Argv<yargsOrig.Defined<{}, K>>;
    required(key: string, msg: string): yargsOrig.Argv<{}>;
    required(key: string, required: boolean): yargsOrig.Argv<{}>;
    required(keys: readonly number[], msg: string): yargsOrig.Argv<{}>;
    required(keys: readonly number[], required: boolean): yargsOrig.Argv<{}>;
    required(positionals: number, required: boolean): yargsOrig.Argv<{}>;
    required(positionals: number, msg: string): yargsOrig.Argv<{}>;
    requiresArg(key: string | readonly string[]): yargsOrig.Argv<{}>;
    reset(): yargsOrig.Argv<{}>;
    scriptName($0: string): yargsOrig.Argv<{}>;
    showCompletionScript(): yargsOrig.Argv<{}>;
    showHidden(option?: string | boolean | undefined): yargsOrig.Argv<{}>;
    showHidden(option: string, description?: string | undefined): yargsOrig.Argv<{}>;
    showHelp(consoleLevel?: string | undefined): yargsOrig.Argv<{}>;
    showHelpOnFail(enable: boolean, message?: string | undefined): yargsOrig.Argv<{}>;
    skipValidation(key: string | readonly string[]): yargsOrig.Argv<{}>;
    strict(): yargsOrig.Argv<{}>;
    strict(enabled: boolean): yargsOrig.Argv<{}>;
    string<K extends never>(key: K | readonly K[]): yargsOrig.Argv<yargsOrig.Omit<{}, K> & { [key in K]: yargsOrig.ToString<{}[key]>; }>;
    string<K extends string>(key: K | readonly K[]): yargsOrig.Argv<{ [key in K]: string | undefined; }>;
    terminalWidth(): number;
    updateLocale(obj: {
        [key: string]: string;
    }): yargsOrig.Argv<{}>;
    updateStrings(obj: {
        [key: string]: string;
    }): yargsOrig.Argv<{}>;
    usage(message: string): yargsOrig.Argv<{}>;
    usage<U>(command: string | readonly string[], description: string, builder?: ((args: yargsOrig.Argv<{}>) => yargsOrig.Argv<U>) | undefined, handler?: ((args: yargsOrig.Arguments<U>) => void) | undefined): yargsOrig.Argv<{}>;
    usage<U>(command: string | readonly string[], showInHelp: boolean, builder?: ((args: yargsOrig.Argv<{}>) => yargsOrig.Argv<U>) | undefined, handler?: ((args: yargsOrig.Arguments<U>) => void) | undefined): yargsOrig.Argv<{}>;
    usage<O extends {
        [key: string]: yargsOrig.Options;
    }>(command: string | readonly string[], description: string, builder?: O | undefined, handler?: ((args: yargsOrig.Arguments<yargsOrig.InferredOptionTypes<O>>) => void) | undefined): yargsOrig.Argv<{}>;
    usage<O extends {
        [key: string]: yargsOrig.Options;
    }>(command: string | readonly string[], showInHelp: boolean, builder?: O | undefined, handler?: ((args: yargsOrig.Arguments<yargsOrig.InferredOptionTypes<O>>) => void) | undefined): yargsOrig.Argv<{}>;
    version(): yargsOrig.Argv<{}>;
    version(version: string): yargsOrig.Argv<{}>;
    version(enable: boolean): yargsOrig.Argv<{}>;
    version(optionKey: string, version: string): yargsOrig.Argv<{}>;
    version(optionKey: string, description: string, version: string): yargsOrig.Argv<{}>;
    wrap(columns: number | null): yargsOrig.Argv<{}>;
};
interface UserResponse {
    me: User;
    teams: Team[];
}
export declare function exec(command: string): Promise<{
    stdout: string;
    stderr: string;
} | Error>;
export declare function getHostOS(): string | undefined;
export declare function homeDir(): string;
export declare function isContainer(): boolean;
export declare function log(...args: any[]): void;
export declare function user(): Promise<UserResponse>;
export declare function getStatePath(): string;
export declare function getConfigPath(): string;
export declare function setState(key: string, value: any): Promise<void>;
export declare function getState(key: string): Promise<any>;
export declare function setConfig(key: string, value: any): Promise<void>;
export declare function getConfig(key: string): Promise<any>;
export declare function track(tags: string[] | string, metadata: object): Promise<void>;
export {};
