"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const axios_1 = __importDefault(require("axios"));
const util_1 = __importDefault(require("util"));
const child_process_1 = __importDefault(require("child_process"));
const is_docker_1 = __importDefault(require("is-docker"));
const os_1 = __importDefault(require("os"));
const state_1 = require("./state");
const config_1 = require("./config");
const yargsOrig = __importStar(require("yargs"));
exports.yargs = yargsOrig;
const pExec = util_1.default.promisify(child_process_1.default.exec);
const API_HOST = process.env.OPS_API_HOST || 'https://cto.ai/';
const API_PATH = process.env.OPS_API_PATH || 'api/v1';
let currentUser;
const apiPathName = path_1.default.join(API_HOST, API_PATH);
async function exec(command) {
    try {
        return pExec(command);
    }
    catch (err) {
        return err;
    }
}
exports.exec = exec;
function getHostOS() {
    return isContainer() ? process.env.OPS_HOST_PLATFORM : os_1.default.platform();
}
exports.getHostOS = getHostOS;
function homeDir() {
    return isContainer() ? '/root' : os_1.default.homedir();
}
exports.homeDir = homeDir;
// TODO: enable other checks besides docker container and host
function isContainer() {
    return is_docker_1.default();
}
exports.isContainer = isContainer;
function log(...args) {
    console.log(...args);
}
exports.log = log;
async function user() {
    const meUrl = new URL(path_1.default.join(apiPathName, '/me'));
    const res = await axios_1.default
        .request({
        url: meUrl.href,
        method: 'GET',
        headers: {
            Authorization: process.env.OPS_ACCESS_TOKEN,
            'Content-Type': 'application/json',
        },
    })
        .catch(err => {
        throw err;
    });
    return res.data.data;
}
exports.user = user;
function getStatePath() {
    return path_1.default.resolve(`${homeDir()}/.config/@cto.ai/ops/${process.env.STATE_DIR}`);
}
exports.getStatePath = getStatePath;
function getConfigPath() {
    return path_1.default.resolve(`${homeDir()}/.config/@cto.ai/ops/${process.env.CONFIG_DIR}`);
}
exports.getConfigPath = getConfigPath;
async function setState(key, value) {
    const state = new state_1.State(getStatePath());
    await state.set(key, value);
}
exports.setState = setState;
async function getState(key) {
    const state = new state_1.State(getStatePath());
    return await state.get(key);
}
exports.getState = getState;
async function setConfig(key, value) {
    const config = new config_1.Config(getConfigPath());
    await config.set(key, value);
}
exports.setConfig = setConfig;
async function getConfig(key) {
    const config = new config_1.Config(getConfigPath());
    return await config.get(key);
}
exports.getConfig = getConfig;
async function track(tags, metadata) {
    const logUrl = new URL(path_1.default.join(apiPathName, '/log/event'));
    if (!currentUser) {
        try {
            currentUser = await user();
        }
        catch (err) {
            // TODO: currently we swallow this error but it should be reported to the server
        }
    }
    try {
        await axios_1.default({
            url: `${logUrl}`,
            method: 'POST',
            headers: {
                Authorization: process.env.OPS_ACCESS_TOKEN,
                'Content-Type': 'application/json',
            },
            data: {
                opid: process.env.OPS_OP_ID,
                teamid: process.env.OPS_TEAM_ID,
                userid: currentUser !== undefined ? currentUser.me.id : undefined,
                metadata,
                tags: Array.isArray(tags) ? tags : [tags],
            },
        });
    }
    catch (err) {
        // TODO: again, just swallowing the error for now. We should be reporting it
    }
}
exports.track = track;
